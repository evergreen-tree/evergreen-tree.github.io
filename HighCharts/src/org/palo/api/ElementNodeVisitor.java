/*
 * (c) Tensegrity Software 2005. All rights reserved.
 */
package org.palo.api;


/**
 * <code>ElementNodeVisitor</code>
 * 
 * Interface methods for an <code>ElementNodeVisitor</code>.
 * 
 * <p>
 * In a given dimension the elements are related to each other depending
 * on their consolidations. An element "Colors" could have three 
 * children "Red", "Green" and "Yellow". This forms a tree of the form
 * <pre>
 * Colors -+- Red
 *         |
 *         +- Green
 *         |
 *         +- Yellow
 * </pre>
 * 
 * A preorder traversal of this tree would result in the following order:
 * "Colors", "Red", "Green", "Yellow". (Parents are visited before
 * their children).
 * </p>
 * 
 * <p>
 * This class defines the signature for the callback that can be passed
 * to {@link org.palo.api.Dimension#visitElementTree(ElementNodeVisitor)}.
 * The pre-order traversal then happens automatically. As each element
 * is encountered the callback is invoked. For convenience the parent
 * node is also provided, but it is null for the roots elements.
 * </p>
 * 
 * <p>
 * Why use <code>ElementNode</code> and not <code>Element</code> directly ?
 * The reason is that an element can be consolidated multiple times within 
 * its parent dimension. So the elements can infact form a DAG
 * (Directed-Acyclic-Graph). An <code>ElementNode</code> wrapps an <code>Element</code>
 * and allows it to be retrieved by invoking the <code>getElement()</code> accessor.
 * The element-nodes are generated by the palo-api and form a tree (more accurately one
 * or more trees). This is sometimes more handy.
 * </p>
 * 
 * <p>
 * Example: Here is a function that prints out a dimension hierarchically
 * by means of an <code>ElementNodeVisitor</code>.
 * <pre>
 *    private static void dumpDimensionHierarchy(Dimension dimension)
 *    {
 *        System.err.println ("dumping dimension '" +
 *            dimension.getName() + "' in database '" +
 *            dimension.getDatabase().getName() + "' ...");
 *
 *        // the following code will "visit" the consolidation tree, that means
 *        // each node in the consolidation tree is processed in pre-order and
 *        // user-supplied callback of type ElementNodeVisitor is invoked
 *        // for each encountered node.
 *        
 *        dimension.visitElementTree(new ElementNodeVisitor() {
 *            public void visit(ElementNode elementNode, ElementNode parent)
 *            {
 *                // Retrieve the element nested in the current ElementNode
 *                Element element = elementNode.getElement();
 *                // Get depth
 *                int depth = element.getDepth();
 *                // indent according to depth
 *                for (int i = 0; i < depth; ++i)
 *                    System.err.print("    ");
 *                System.err.println(element.getName());
 *            }
 *        });
 *    }
 * </pre>
 * </p>
 * 
 * @author Stepan Rutz
 * @version $ID$
 */
public interface ElementNodeVisitor
{
    /**
     * Called during element-node visiting.
     * @param elementNode the current {@link ElementNode}.
     * @param parent the parent {@link ElementNode}, maybe <code>null</code>.
     */
    void visit(ElementNode elementNode, ElementNode parent);
}

